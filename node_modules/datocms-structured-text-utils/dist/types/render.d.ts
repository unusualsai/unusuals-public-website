import { Node, Record, Document, StructuredText } from './types';
export declare class RenderError extends Error {
    node: Node;
    constructor(message: string, node: Node);
}
export declare type TrasformFn = (...args: any[]) => any;
export declare type RenderResult<H extends TrasformFn, T extends TrasformFn, F extends TrasformFn> = ReturnType<H> | ReturnType<T> | ReturnType<F> | null | undefined;
export declare type RenderContext<H extends TrasformFn, T extends TrasformFn, F extends TrasformFn, N extends Node> = {
    adapter: Adapter<H, T, F>;
    node: N;
    ancestors: Node[];
    key: string;
    children: Exclude<RenderResult<H, T, F>, null | undefined>[] | undefined;
};
export interface RenderRule<H extends TrasformFn, T extends TrasformFn, F extends TrasformFn> {
    appliable: (node: Node) => boolean;
    apply: (ctx: RenderContext<H, T, F, Node>) => RenderResult<H, T, F>;
}
export declare const renderRule: <N extends Node, H extends TrasformFn, T extends TrasformFn, F extends TrasformFn>(guard: (node: Node) => node is N, transform: (ctx: RenderContext<H, T, F, N>) => RenderResult<H, T, F>) => RenderRule<H, T, F>;
export declare function transformNode<H extends TrasformFn, T extends TrasformFn, F extends TrasformFn>(adapter: Adapter<H, T, F>, node: Node, key: string, ancestors: Node[], renderRules: RenderRule<H, T, F>[]): RenderResult<H, T, F>;
export declare type Adapter<H extends TrasformFn, T extends TrasformFn, F extends TrasformFn> = {
    renderNode: H;
    renderText: T;
    renderFragment: F;
};
export declare function render<H extends TrasformFn, T extends TrasformFn, F extends TrasformFn, R extends Record>(adapter: Adapter<H, T, F>, structuredTextOrNode: StructuredText<R> | Document | Node | null | undefined, renderRules: RenderRule<H, T, F>[]): RenderResult<H, T, F>;
