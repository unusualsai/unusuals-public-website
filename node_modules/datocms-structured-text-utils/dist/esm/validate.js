var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { allowedAttributes, allowedMarks, allowedChildren, inlineNodeTypes, } from './definitions';
export function validate(document) {
    if (document === null || document === undefined) {
        return { valid: true };
    }
    if (document.schema !== 'dast') {
        return {
            valid: false,
            message: ".schema is not \"dast\":\n\n " + JSON.stringify(document, null, 2),
        };
    }
    var nodes = [document.document];
    var node = document.document;
    var _loop_1 = function () {
        var next = nodes.pop();
        if (!next) {
            return "break";
        }
        node = next;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var type = node.type, attributes = __rest(node, ["type"]);
        var invalidAttribute = Object.keys(attributes).find(function (attr) { return !allowedAttributes[node.type].includes(attr); });
        if (invalidAttribute) {
            return { value: {
                    valid: false,
                    message: "\"" + node.type + "\" has an invalid attribute \"" + invalidAttribute + "\":\n\n " + JSON.stringify(node, null, 2),
                } };
        }
        if ('meta' in node) {
            if (!Array.isArray(node.meta)) {
                return { value: {
                        valid: false,
                        message: "\"" + node.type + "\"'s meta is not an Array:\n\n " + JSON.stringify(node, null, 2),
                    } };
            }
            var invalidMeta = node.meta.find(function (entry) {
                return typeof entry !== 'object' ||
                    !('id' in entry) ||
                    !('value' in entry) ||
                    typeof entry.value !== 'string';
            });
            if (invalidMeta) {
                return { value: {
                        valid: false,
                        message: "\"" + node.type + "\" has an invalid meta " + JSON.stringify(invalidMeta) + ":\n\n " + JSON.stringify(node, null, 2),
                    } };
            }
        }
        if ('marks' in node) {
            if (!Array.isArray(node.marks)) {
                return { value: {
                        valid: false,
                        message: "\"" + node.type + "\"'s marks is not an Array:\n\n " + JSON.stringify(node, null, 2),
                    } };
            }
            var invalidMark = node.marks.find(function (mark) { return !allowedMarks.includes(mark); });
            if (invalidMark) {
                return { value: {
                        valid: false,
                        message: "\"" + node.type + "\" has an invalid mark \"" + invalidMark + "\":\n\n " + JSON.stringify(node, null, 2),
                    } };
            }
        }
        if ('children' in node) {
            if (!Array.isArray(node.children)) {
                return { value: {
                        valid: false,
                        message: "\"" + node.type + "\"'s children is not an Array:\n\n " + JSON.stringify(node, null, 2),
                    } };
            }
            if (node.children.length === 0) {
                return { value: {
                        valid: false,
                        message: "\"" + node.type + "\"'s children cannot be an empty Array:\n\n " + JSON.stringify(node, null, 2),
                    } };
            }
            var allowed_1 = allowedChildren[node.type];
            if (typeof allowed_1 === 'string' && allowed_1 === 'inlineNodes') {
                allowed_1 = inlineNodeTypes;
            }
            var invalidChildIndex = node.children.findIndex(function (child) { return !child || !allowed_1.includes(child.type); });
            if (invalidChildIndex !== -1) {
                var invalidChild = node.children[invalidChildIndex];
                return { value: {
                        valid: false,
                        message: "\"" + node.type + "\" has invalid child \"" + (invalidChild ? invalidChild.type : invalidChild) + "\":\n\n " + JSON.stringify(node, null, 2),
                    } };
            }
            for (var i = node.children.length - 1; i >= 0; i--) {
                nodes.push(node.children[i]);
            }
        }
    };
    while (nodes.length > 0) {
        var state_1 = _loop_1();
        if (typeof state_1 === "object")
            return state_1.value;
        if (state_1 === "break")
            break;
    }
    return {
        valid: true,
    };
}
//# sourceMappingURL=validate.js.map