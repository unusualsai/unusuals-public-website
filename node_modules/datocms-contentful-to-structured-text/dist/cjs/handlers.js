"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.handlers = exports.resolveUrl = exports.wrapListItems = exports.noop = exports.link = exports.codeBlock = exports.listItem = exports.list = exports.blockquote = exports.heading = exports.thematicBreak = exports.paragraph = exports.span = exports.root = void 0;
/* eslint-disable @typescript-eslint/ban-ts-comment */
// @ts-nocheck
var datocms_structured_text_utils_1 = require("datocms-structured-text-utils");
var rich_text_types_1 = require("@contentful/rich-text-types");
var wrap_1 = require("./wrap");
var visit_children_1 = __importDefault(require("./visit-children"));
var index_1 = require("./index");
var root = function root(createNode, node, context) {
    return __awaiter(this, void 0, void 0, function () {
        var children;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, visit_children_1.default(createNode, node, __assign(__assign({}, context), { parentNodeType: 'root' }))];
                case 1:
                    children = _a.sent();
                    if (!Array.isArray(children) || children.length === 0) {
                        return [2 /*return*/, null];
                    }
                    if (children.some(function (child) {
                        return child && !datocms_structured_text_utils_1.allowedChildren.root.includes(child.type);
                    })) {
                        children = wrap_1.wrap(children);
                    }
                    return [2 /*return*/, createNode('root', { children: children })];
            }
        });
    });
};
exports.root = root;
var span = function span(createNode, node, context) {
    return __awaiter(this, void 0, void 0, function () {
        var marks, allowedMarks;
        return __generator(this, function (_a) {
            marks = {};
            if (Array.isArray(node.marks) && node.marks.length > 0) {
                allowedMarks = node.marks
                    .map(function (m) { return m.type; })
                    .filter(function (mark) {
                    return context.allowedMarks.includes(index_1.datoToContentfulMarks[mark]);
                });
                if (allowedMarks.length > 0) {
                    marks.marks = allowedMarks.map(function (m) { return index_1.datoToContentfulMarks[m]; });
                }
            }
            return [2 /*return*/, createNode('span', __assign({ value: node.value }, marks))];
        });
    });
};
exports.span = span;
var paragraph = function paragraph(createNode, node, context) {
    return __awaiter(this, void 0, void 0, function () {
        var isAllowedChild, children;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    isAllowedChild = datocms_structured_text_utils_1.allowedChildren[context.parentNodeType].includes('paragraph');
                    return [4 /*yield*/, visit_children_1.default(createNode, node, __assign(__assign({}, context), { parentNodeType: isAllowedChild ? 'paragraph' : context.parentNodeType }))];
                case 1:
                    children = _a.sent();
                    if (Array.isArray(children) && children.length) {
                        // Code block gets created only if in root and not inline
                        if (children.length === 1 &&
                            children[0].marks &&
                            children[0].marks.length === 1 &&
                            children[0].marks.includes('code') &&
                            context.allowedBlocks.includes('code') &&
                            context.parentNode.nodeType === 'document') {
                            return [2 /*return*/, exports.codeBlock(createNode, children[0])];
                        }
                        return [2 /*return*/, isAllowedChild ? createNode('paragraph', { children: children }) : children];
                    }
                    return [2 /*return*/, undefined];
            }
        });
    });
};
exports.paragraph = paragraph;
var thematicBreak = function thematicBreak(createNode, node, context) {
    return __awaiter(this, void 0, void 0, function () {
        var isAllowedChild;
        return __generator(this, function (_a) {
            isAllowedChild = datocms_structured_text_utils_1.allowedChildren[context.parentNodeType].includes('thematicBreak');
            return [2 /*return*/, isAllowedChild ? createNode('thematicBreak', {}) : undefined];
        });
    });
};
exports.thematicBreak = thematicBreak;
var heading = function heading(createNode, node, context) {
    return __awaiter(this, void 0, void 0, function () {
        var isAllowedChild, children;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    isAllowedChild = datocms_structured_text_utils_1.allowedChildren[context.parentNodeType].includes('heading') &&
                        context.allowedBlocks.includes('heading');
                    return [4 /*yield*/, visit_children_1.default(createNode, node, __assign(__assign({}, context), { parentNodeType: isAllowedChild ? 'heading' : context.parentNodeType }))];
                case 1:
                    children = _a.sent();
                    if (Array.isArray(children) && children.length) {
                        return [2 /*return*/, isAllowedChild
                                ? createNode('heading', {
                                    level: Number(node.nodeType.slice(-1)) || 1,
                                    children: children,
                                })
                                : children];
                    }
                    return [2 /*return*/, undefined];
            }
        });
    });
};
exports.heading = heading;
var blockquote = function blockquote(createNode, node, context) {
    return __awaiter(this, void 0, void 0, function () {
        var isAllowedChild, children;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    isAllowedChild = datocms_structured_text_utils_1.allowedChildren[context.parentNodeType].includes('blockquote') &&
                        context.allowedBlocks.includes('blockquote');
                    return [4 /*yield*/, visit_children_1.default(createNode, node, __assign(__assign({}, context), { parentNodeType: isAllowedChild ? 'blockquote' : context.parentNodeType }))];
                case 1:
                    children = _a.sent();
                    if (Array.isArray(children) && children.length) {
                        return [2 /*return*/, isAllowedChild ? createNode('blockquote', { children: children }) : children];
                    }
                    return [2 /*return*/, undefined];
            }
        });
    });
};
exports.blockquote = blockquote;
var list = function list(createNode, node, context) {
    return __awaiter(this, void 0, void 0, function () {
        var isAllowedChild, children;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    isAllowedChild = datocms_structured_text_utils_1.allowedChildren[context.parentNodeType].includes('list') &&
                        context.allowedBlocks.includes('list');
                    if (!!isAllowedChild) return [3 /*break*/, 2];
                    return [4 /*yield*/, visit_children_1.default(createNode, node, context)];
                case 1: return [2 /*return*/, _a.sent()];
                case 2: return [4 /*yield*/, exports.wrapListItems(createNode, node, __assign(__assign({}, context), { parentNodeType: 'list' }))];
                case 3:
                    children = _a.sent();
                    if (Array.isArray(children) && children.length) {
                        return [2 /*return*/, createNode('list', {
                                children: children,
                                style: node.nodeType === 'ordered-list' ? 'numbered' : 'bulleted',
                            })];
                    }
                    return [2 /*return*/, undefined];
            }
        });
    });
};
exports.list = list;
var listItem = function listItem(createNode, node, context) {
    return __awaiter(this, void 0, void 0, function () {
        var isAllowedChild, children;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    isAllowedChild = datocms_structured_text_utils_1.allowedChildren[context.parentNodeType].includes('listItem') &&
                        context.allowedBlocks.includes('list');
                    return [4 /*yield*/, visit_children_1.default(createNode, node, __assign(__assign({}, context), { parentNodeType: isAllowedChild ? 'listItem' : context.parentNodeType }))];
                case 1:
                    children = _a.sent();
                    if (Array.isArray(children) && children.length) {
                        return [2 /*return*/, isAllowedChild
                                ? createNode('listItem', { children: wrap_1.wrap(children) })
                                : children];
                    }
                    return [2 /*return*/, undefined];
            }
        });
    });
};
exports.listItem = listItem;
var codeBlock = function codeBlock(createNode, node) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, createNode('code', {
                    code: node.value,
                })];
        });
    });
};
exports.codeBlock = codeBlock;
var link = function link(createNode, node, context) {
    return __awaiter(this, void 0, void 0, function () {
        var isAllowedChild, allowedChildrenWrapped, children, props, meta_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!context.allowedBlocks.includes('link')) {
                        return [2 /*return*/, visit_children_1.default(createNode, node, context)];
                    }
                    isAllowedChild = false;
                    if (datocms_structured_text_utils_1.allowedChildren[context.parentNodeType] === 'inlineNodes') {
                        isAllowedChild = datocms_structured_text_utils_1.inlineNodeTypes.includes('link');
                    }
                    else if (Array.isArray(datocms_structured_text_utils_1.allowedChildren[context.parentNodeType])) {
                        isAllowedChild = datocms_structured_text_utils_1.allowedChildren[context.parentNodeType].includes('link');
                    }
                    if (!isAllowedChild) {
                        allowedChildrenWrapped = ['root', 'list', 'listItem'];
                        isAllowedChild = allowedChildrenWrapped.includes(context.parentNodeType);
                    }
                    return [4 /*yield*/, visit_children_1.default(createNode, node, __assign(__assign({}, context), { parentNodeType: isAllowedChild ? 'link' : context.parentNodeType }))];
                case 1:
                    children = _a.sent();
                    if (Array.isArray(children) && children.length) {
                        if (!isAllowedChild) {
                            return [2 /*return*/, children];
                        }
                        props = {
                            url: resolveUrl(context, node.data.uri),
                            children: children,
                        };
                        meta_1 = [];
                        if (node.properties) {
                            ['target', 'rel', 'title'].forEach(function (attr) {
                                var value = Array.isArray(node.properties[attr])
                                    ? node.properties[attr].join(' ')
                                    : node.properties[attr];
                                if (value) {
                                    meta_1.push({ id: attr, value: value });
                                }
                            });
                        }
                        if (meta_1.length > 0) {
                            props.meta = meta_1;
                        }
                        return [2 /*return*/, createNode('link', props)];
                    }
                    return [2 /*return*/, undefined];
            }
        });
    });
};
exports.link = link;
// eslint-disable-next-line @typescript-eslint/no-empty-function,  @typescript-eslint/explicit-module-boundary-types
function noop() {
    return __awaiter(this, void 0, void 0, function () { return __generator(this, function (_a) {
        return [2 /*return*/];
    }); });
}
exports.noop = noop;
var wrapListItems = function wrapListItems(createNode, node, context) {
    return __awaiter(this, void 0, void 0, function () {
        var children, index;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, visit_children_1.default(createNode, node, context)];
                case 1:
                    children = _a.sent();
                    if (!Array.isArray(children)) {
                        return [2 /*return*/, []];
                    }
                    index = -1;
                    while (++index < children.length) {
                        if (typeof children[index] !== 'undefined' &&
                            children[index].type !== 'listItem') {
                            children[index] = {
                                type: 'listItem',
                                children: [
                                    datocms_structured_text_utils_1.allowedChildren.listItem.includes(children[index].type)
                                        ? children[index]
                                        : createNode('paragraph', { children: [children[index]] }),
                                ],
                            };
                        }
                    }
                    return [2 /*return*/, children];
            }
        });
    });
};
exports.wrapListItems = wrapListItems;
function resolveUrl(context, url) {
    if (url === null || url === undefined) {
        return '';
    }
    if (context.global.baseUrl && typeof URL !== 'undefined') {
        var isRelative = /^\.?\//.test(url);
        var parsed = new URL(url, context.global.baseUrl);
        if (isRelative) {
            var parsedBase = new URL(context.global.baseUrl);
            if (!parsed.pathname.startsWith(parsedBase.pathname)) {
                parsed.pathname = "" + parsedBase.pathname + parsed.pathname;
            }
        }
        return parsed.toString();
    }
    return url;
}
exports.resolveUrl = resolveUrl;
exports.handlers = (_a = {
        text: exports.span
    },
    _a[rich_text_types_1.BLOCKS.DOCUMENT] = exports.root,
    _a[rich_text_types_1.BLOCKS.PARAGRAPH] = exports.paragraph,
    _a[rich_text_types_1.BLOCKS.HEADING_1] = exports.heading,
    _a[rich_text_types_1.BLOCKS.HEADING_2] = exports.heading,
    _a[rich_text_types_1.BLOCKS.HEADING_3] = exports.heading,
    _a[rich_text_types_1.BLOCKS.HEADING_4] = exports.heading,
    _a[rich_text_types_1.BLOCKS.HEADING_5] = exports.heading,
    _a[rich_text_types_1.BLOCKS.HEADING_6] = exports.heading,
    _a[rich_text_types_1.BLOCKS.UL_LIST] = exports.list,
    _a[rich_text_types_1.BLOCKS.OL_LIST] = exports.list,
    _a[rich_text_types_1.BLOCKS.LIST_ITEM] = exports.listItem,
    _a[rich_text_types_1.BLOCKS.QUOTE] = exports.blockquote,
    _a[rich_text_types_1.BLOCKS.HR] = exports.thematicBreak,
    _a[rich_text_types_1.INLINES.HYPERLINK] = exports.link,
    _a[rich_text_types_1.INLINES.EMBEDDED_ENTRY] = noop,
    _a[rich_text_types_1.BLOCKS.EMBEDDED_ASSET] = noop,
    _a[rich_text_types_1.BLOCKS.EMBEDDED_ENTRY] = noop,
    _a[rich_text_types_1.INLINES.ASSET_HYPERLINK] = noop,
    _a[rich_text_types_1.INLINES.ENTRY_HYPERLINK] = noop,
    _a);
//# sourceMappingURL=handlers.js.map