"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var comment_parser_1 = require("./comment-parser");
var gonzales = require('gonzales-pe');
var ScssParser = /** @class */ (function () {
    function ScssParser() {
    }
    ScssParser.prototype.parse = function (tokenFiles) {
        var tokenGroups = this.mapTokenFilesToTokenGroups(tokenFiles);
        return {
            hardCodedValues: this.mapTokenFilesToHardCodedValues(tokenFiles, tokenGroups),
            keyframes: this.mapTokenFilesToKeyframes(tokenFiles),
            tokenGroups: this.mapTokenFilesToTokenGroups(tokenFiles)
        };
    };
    ScssParser.prototype.mapTokenFilesToHardCodedValues = function (tokenFiles, tokenGroups) {
        var _this = this;
        if (!tokenFiles.scss) {
            return [];
        }
        var hardCodedValues = [];
        var tokens = tokenGroups.map(function (tokenGroup) { return tokenGroup.tokens; }).flat();
        tokenFiles.scss.forEach(function (tokenFile) {
            var parsed = gonzales.parse(tokenFile.content, { syntax: 'scss' });
            parsed.traverseByType('block', function (block) {
                block.forEach('declaration', function (declaration) {
                    var value = declaration.first('value');
                    if (!value.is('variable')) {
                        hardCodedValues.push({
                            file: tokenFile.filename,
                            line: value.start.line,
                            value: _this.mapPropertyValue(value)
                        });
                    }
                });
            });
        });
        return tokens
            .map(function (token) { return ({
            token: token,
            values: hardCodedValues.filter(function (value) { return value.value && value.value.indexOf(token.value) > -1; })
        }); })
            .filter(function (item) { return item.values.length > 0; });
    };
    ScssParser.prototype.mapTokenFilesToKeyframes = function (tokenFiles) {
        if (!tokenFiles || !tokenFiles.scss) {
            return '';
        }
        return tokenFiles.scss
            .map(function (tokenFile) {
            var parsed = gonzales.parse(tokenFile.content, { syntax: 'scss' });
            return parsed.content
                .filter(function (item) { return item.type === 'atrule'; })
                .filter(function (item) {
                return item.content.find(function (node) {
                    return node.type === 'atkeyword' &&
                        node.content.find(function (n) { return n.content === 'keyframes'; });
                });
            });
        })
            .flat()
            .join('');
    };
    ScssParser.prototype.mapTokenFilesToTokenGroups = function (tokenFiles) {
        var _this = this;
        if (!tokenFiles || !tokenFiles.scss) {
            return [];
        }
        var parsedTokenFiles = tokenFiles.scss.map(function (tokenFile) {
            return gonzales.parse(tokenFile.content, { syntax: 'scss' });
        });
        return parsedTokenFiles
            .map(function (tokenFile) {
            var tokenGroups = tokenFile.content
                .filter(function (item) {
                return item.type === 'multilineComment' &&
                    item.content.indexOf('@tokens') > -1;
            })
                .map(function (item) { return (__assign(__assign({}, item), { parsedText: _this.parseCommentBlock(item.content) })); })
                .map(function (item, index, items) {
                return _this.mapTokenGroup(item, items[index + 1], tokenFile.content, parsedTokenFiles.map(function (tokenFile) { return tokenFile.content; }));
            });
            return tokenGroups;
        })
            .flat();
    };
    ScssParser.prototype.mapTokenGroup = function (item, nextItem, parsedTokenFile, parsedTokenFiles) {
        var presenterTag = item.parsedText.tags.find(function (t) { return t.tag === 'presenter'; });
        return this.addTokensToTokenGroup({
            label: item.parsedText.tags
                .find(function (t) { return t.tag === 'tokens'; })
                .source.replace('@tokens', '')
                .trim(),
            position: {
                start: item.start.line,
                end: nextItem ? nextItem.start.line - 1 : Infinity
            },
            presenter: presenterTag ? presenterTag.name : undefined,
            tokens: []
        }, parsedTokenFile, parsedTokenFiles);
    };
    ScssParser.prototype.addTokensToTokenGroup = function (tokenGroup, parsedTokenFile, parsedTokenFiles) {
        var _this = this;
        var relevantRules = parsedTokenFile
            .filter(function (item) { return item.type === 'declaration'; })
            .filter(function (item) {
            return item.start.line >= tokenGroup.position.start &&
                item.end.line <= tokenGroup.position.end;
        });
        var allAliases = parsedTokenFiles
            .map(function (parsedTokenFile) {
            return parsedTokenFile
                .filter(function (node) {
                return node.is('declaration') &&
                    node.contains('value') &&
                    node.first('value').contains('variable');
            })
                .map(function (node) { return ({
                alias: node.first('property').first('variable').first('ident')
                    .content,
                source: node.first('value').first('variable').first('ident').content
            }); });
        })
            .flat();
        var allComments = parsedTokenFile.filter(function (node) { return node.is('singlelineComment') || node.is('multilineComment'); });
        var tokens = !relevantRules
            ? []
            : relevantRules
                .filter(function (declaration) {
                return declaration.contains('property') &&
                    declaration.contains('value') &&
                    !declaration.first('value').contains('variable');
            })
                .map(function (declaration) {
                var key = declaration.first('property').first('variable').content;
                var aliases = allAliases
                    .filter(function (alias) { return alias.source === key[0].content; })
                    .map(function (alias) { return '$' + alias.alias; });
                var description = allComments.find(function (c) {
                    return c.start.line === declaration.start.line &&
                        c.end.line === declaration.end.line;
                });
                return {
                    aliases: aliases,
                    description: description ? description.content : '',
                    editable: false,
                    key: '$' + key,
                    value: _this.mapPropertyValue(declaration.first('value'))
                };
            });
        return __assign(__assign({}, tokenGroup), { tokens: tokens });
    };
    ScssParser.prototype.mapPropertyValue = function (value) {
        return this.reducePropertyValues(value);
    };
    ScssParser.prototype.reducePropertyValues = function (value, reduced) {
        var _this = this;
        if (reduced === void 0) { reduced = ''; }
        return value.content
            .filter(function (node) { return node.type !== 'default' && node.type !== 'global'; })
            .reduce(function (v, node, index, list) {
            if (typeof node.content === 'string') {
                var type = value.type === 'percentage' ? value.type : node.type;
                node.content = _this.addValueUnit(node.content, type);
            }
            if (value.type === 'function' && index > 0) {
                return v;
            }
            if (typeof node.content !== 'string') {
                return _this.reducePropertyValues(node, v);
            }
            if (value.type === 'function') {
                return "" + v + node.content + "(" + _this.reducePropertyValues(list[index + 1]) + ")";
            }
            return "" + v + node.content;
        }, reduced)
            .trim();
    };
    ScssParser.prototype.addValueUnit = function (value, type) {
        if (type === 'color') {
            return "#" + value;
        }
        if (type === 'percentage') {
            return value + "%";
        }
        return value;
    };
    ScssParser.prototype.parseCommentBlock = function (string) {
        return comment_parser_1.parse("/*" + string + "*/")[0];
    };
    return ScssParser;
}());
exports.ScssParser = ScssParser;
